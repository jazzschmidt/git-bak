#!/bin/bash -e

# Register cleanup
trap cleanup EXIT SIGINT SIGTERM

SCRIPT_NAME=$(basename $0)
WORKING_DIR=$(pwd)

# Disabled when not in verbose mode
LOG="/dev/null"

# Disabled when -x or --no-script is set
CREATE_CLONE_SCRIPT=true

# Repository url
URL=

# Humanish name of the repository
REPO_NAME=

# Archive name
FILE=

# Temporary diretory to clone to
CLONE_DIR=

# Which files to archive
ARCHIVE_FILES=

function main() {
  # Read arguments
  parse_args $*

  log "Determining repository name from $URL"
  REPO_NAME=$(get_url_repository_name "$URL")
  log "Repository name: $REPO_NAME"

  # Set file name
  if [ -z "$FILE" ]; then
    FILE=$WORKING_DIR/${REPO_NAME}.tar.gz
  fi

  log "File path: $FILE"

  # Create clone directory
  CLONE_DIR=$(mktemp -d "${TMPDIR:-/tmp}/${SCRIPT_NAME}.XXX")
  log "Cloning into: $CLONE_DIR"

  # Create the backup
  create_backup

  ARCHIVE_FILES="gitbundle"
  if [ "$CREATE_CLONE_SCRIPT" = "true" ]; then ARCHIVE_FILES="$ARCHIVE_FILES checkout"; fi

  # Create archive
  tar -czf $FILE -C $CLONE_DIR $ARCHIVE_FILES
}

function get_arg() {
  local args=$1
  local key1=$2; local key2=$3;
  local arg
  local found_key=false

  for arg in $args; do
    if [ "$found_key" = true ]; then val=$arg; break; fi
    if [[ "$arg " = "$key1 " ]] || [[ "$arg " = "$key2 " ]]; then found_key=true; fi
    if [[ "$arg" = "$key1="* ]] || [[ "$arg" = "$key2="* ]]; then found_key=true; val="${arg#*=}"; break; fi
  done

  echo "$val"
  return $($found_key)
}

function get_arg_req() {
  arg=$(get_arg "$1" ${*:2})
  test -n "$arg"
}

function get_arg_opt() {
  get_arg "$1" ${*:2} || echo ""
}

function has_arg() {
  get_arg "$1" ${*:2} >/dev/null
}

function get_unmatched_arg() {
  local args=$1; local arg; local valid=${*:2}
  for arg in $args; do
    if [[ "$arg" = -* ]] && [[ ! " ${valid[*]} " = *" $arg "* ]]; then
      echo "$arg"; break
    fi
  done
}

function parse_args() {
  argv=$*

  unknown_arg=$(get_unmatched_arg "$argv" \
    -u --url \
    -f --file \
    -h --help \
    -v --verbose \
    -x --no-script
  )
  if ! [ -z "$unknown_arg" ]; then
    err "Unknown argument: $unknown_arg"; exit 1;
  fi


  URL=$(get_arg_req "$argv" -u --url) || err "Repository url must be specified."
  FILE=$(get_arg_opt "$argv" -f --file)

  if has_arg "$argv" -h --help; then
    print_usage; exit
  fi

  if has_arg "$argv" -v --verbose; then
    LOG=1; log "Increasing verbosity"
  fi

  if has_arg "$argv" -x --no-script; then
    CREATE_CLONE_SCRIPT=false
  fi
}

function create_backup() {
  (
    cd $CLONE_DIR
    git clone --mirror $URL . 1>&$LOG

    # Create git bundle
    git bundle create "gitbundle" --all 1>&$LOG

    # Add simple checkout script
    if [ "$CREATE_CLONE_SCRIPT" = "true" ]; then
      log "Creating clone script for $REPO_NAME"
      create_clone_script "checkout" $REPO_NAME
      chmod +x checkout
    fi
  )
}

function b() {
  tput bold; printf "$1"; tput sgr0;
}

function u() {
  tput smul; printf "$1"; tput sgr0;
}

function err() {
  >&2 printf "[ERROR] $1\n"
  >&2 printf "Try '$SCRIPT_NAME --help' for more information\n"
  exit 1
}

function log() {
  >&$LOG printf "[INFO] $1\n"
}

function print_usage() {
  cat << EOF
$(b NAME)
    $SCRIPT_NAME - Backup a Git repository

$(b SYNOPSIS)
    $SCRIPT_NAME [-x] [-f $(u archive)] -u $(u url)

$(b DESCRIPTION)
    Backups a Git repository by bundling it with all its references. The bundle is then packed as tar ball.
    The archive will be placed in the current directory by default.

    Unless otherwise specified via '-x' or '--no-script', a simple script to conveniently clone the bundle into the current directory is added to archive.

$(b OPTIONS:)
    -f, --file <FILE>   Custom path for the generated tar ball
    -u, --url <URL>     Tells which url to clone the Git repository from
    -h, --help          Shows this help message
    -v, --verbose       Increases verbosity
    -x, --no-script     Skips creation of the clone script

$(b EXAMPLES:)
    Backup a remote repository that is saved as 'repo.tar.gz' in the current directory along with the clone script.

        $SCRIPT_NAME -u https://example.com/projects/repo.git

EOF
}

function get_url_repository_name() {
  url=$1

  # Remove trailing / from url
  if [[ "$url" = */ ]]; then url=${url##*/}; fi

  # Extract last path
  url=${url##*/}

  # Remove git prefix
  printf ${url%*.git}
}

function cleanup() {
  # Remove the temporary clone dir
  if ! [ -z "$CLONE_DIR" ]; then
    log "Removing temprorary clone directory"
    rm -rf $CLONE_DIR
  fi
}

function create_clone_script() {
  file=$1
  clone_dir=$2

  cat > $file <<EOF
#!/bin/bash -e

DIR=\$(dirname \$0)

# Clone into current dir or use script parameters
LOCAL_REPO=\${*:-${clone_dir}}

(
  cd \$DIR
  git clone gitbundle \$LOCAL_REPO
)

EOF
}

main "$@"
