#!/bin/bash

# Register cleanup
trap cleanup EXIT SIGINT SIGTERM

SCRIPT_NAME=$(basename $0)
WORKING_DIR=$(pwd)

# Disabled when not in verbose mode
LOG="/dev/null"

# Disabled when -x or --no-script is set
CREATE_CLONE_SCRIPT=true

# Repository url
URL=

# Humanish name of the repository
REPO_NAME=

# Archive name
FILE=

# Temporary diretory to clone to
CLONE_DIR=

# Which files to archive
ARCHIVE_FILES=

function main() {
  # Read arguments
  parse_args $*

  # Verify url
  if [ -z "$URL" ]; then
    err "Repository url must be specified."
    exit 1
  fi

  log "Determining repository name from $URL"
  REPO_NAME=$(get_url_repository_name "$URL")
  log "Repository name: $REPO_NAME"

  # Set file name
  if [ -z "$FILE" ]; then
    FILE=$WORKING_DIR/${REPO_NAME}.tar.gz
  fi

  log "File path: $FILE"

  # Verify file
  touch $FILE &>/dev/null
  if [ $? -gt 0 ]; then
    err "Cannot create file: $FILE"
    exit 1
  fi

  # Create clone directory
  CLONE_DIR=$(mktemp -d "${TMPDIR:-/tmp}/${SCRIPT_NAME}.XXX")
  log "Cloning into: $CLONE_DIR"

  # Create the backup
  (
    cd $CLONE_DIR
    git clone --mirror $URL . 1>&$LOG

    # Create git bundle
    git bundle create "gitbundle" --all 1>&$LOG

    # Add simple checkout script
    if [ "$CREATE_CLONE_SCRIPT" = "true" ]; then
      log "Creating clone script for $REPO_NAME"
      create_clone_script "checkout" $REPO_NAME
      chmod +x checkout
    fi
  )

  ARCHIVE_FILES="gitbundle"
  if [ "$CREATE_CLONE_SCRIPT" = "true" ]; then ARCHIVE_FILES="$ARCHIVE_FILES checkout"; fi

  # Create archive
  tar -czf $FILE -C $CLONE_DIR $ARCHIVE_FILES
}

function parse_args() {
  while [ $# -gt 0 ]; do
    case "$1" in
      --url*|-u*)
        if [[ "$1" != *=* ]]; then shift; fi
        URL="${1#*=}"
        ;;
      --file*|-f*)
        if [[ "$1" != *=* ]]; then shift; fi
        FILE="${1#*=}"
        ;;
      --help|-h)
        print_usage
        exit
        ;;
      --verbose|-v)
        LOG=1
        log "Increasing verbosity"
        ;;
      -x|--no-script)
        CREATE_CLONE_SCRIPT=false
        ;;
      *)
        err "Unknown argument: $1"
        exit 1
        ;;
    esac
    shift
  done
}

function b() {
  tput bold; printf "$1"; tput sgr0;
}

function u() {
  tput smul; printf "$1"; tput sgr0;
}

function err() {
  >&2 printf "$1\n"
  >&2 printf "Try '$SCRIPT_NAME --help' for more information\n"
}

function log() {
  >&$LOG printf "[INFO] $1\n"
}

function print_usage() {
  cat << EOF
$(b NAME)
    $SCRIPT_NAME - Backup a Git repository

$(b SYNOPSIS)
    $SCRIPT_NAME [-x] [-f $(u archive)] -u $(u url)

$(b DESCRIPTION)
    Backups a Git repository by bundling it with all its references. The bundle is then packed as tar ball.
    The archive will be placed in the current directory by default.

    Unless otherwise specified via '-x' or '--no-script', a simple script to conveniently clone the bundle into the current directory is added to archive.

$(b OPTIONS:)
    -f, --file <FILE>   Custom path for the generated tar ball
    -u, --url <URL>     Tells which url to clone the Git repository from
    -h, --help          Shows this help message
    -v, --verbose       Increases verbosity
    -x, --no-script     Skips creation of the clone script

$(b EXAMPLES:)
    Backup a remote repository that is saved as 'repo.tar.gz' in the current directory along with the clone script.

        $SCRIPT_NAME -u https://example.com/projects/repo.git

EOF
}

function get_url_repository_name() {
  url=$1

  # Remove trailing / from url
  if [[ "$url" = */ ]]; then url=${url##*/}; fi

  # Extract last path
  url=${url##*/}

  # Remove git prefix
  printf ${url%*.git}
}

function cleanup() {
  # Remove the temporary clone dir
  if ! [ -z "$CLONE_DIR" ]; then
    log "Removing temprorary clone directory"
    rm -rf $CLONE_DIR
  fi
}

function create_clone_script() {
  file=$1
  clone_dir=$2

  cat > $file <<EOF
#!/bin/bash -e

DIR=\$(dirname \$0)

# Clone into current dir or use script parameters
LOCAL_REPO=\${*:-${clone_dir}}

(
  cd \$DIR
  git clone gitbundle \$LOCAL_REPO
)

EOF
}

main "$@"
